// 最开始思路是一个一个算，发现太慢了
// 转换思路，一个位置一个位置算，如果n大于等于10的x次方，那么除以10的x次方再乘以10的x-1次方，就可以得到后x位之前这个位置的1的数量
// 然后再处理小于10的x次方的部分，判断当前位置的余数数量即可
// 例如数字123，首先考虑个位的数字数量，除以10答案是12，也就是说不考虑最后的120, 121, 122, 123的情况下，个位数出现了 120 / 10 * 1 = 12个1。然后对10的余数3大于1，也就是会 min(3 - 1 + 1, 1) = 1 个个位数的1
// 然后是十位，123 / 100 * 10 = 10，也就是抛开最后的100到123，一共出现了一个十位数的1，然后考虑23，大于10，所以还会出现 min(23 - 10 + 1, 10) = 10 个十位数的1，分别是110到119.
// 最后是百位，123 / 1000 * 100, = 0，也就是抛开0 - 123，没有百位数的1。然后考虑123， 大于100，所以还会出现 min(123 - 100 + 1, 100) = 24个百位数的1，分别是100到123.

class Solution {
public:
    int countDigitOne(int n) {
        int count = 0;
        int base1 = 1;
        int base2 = base1 * 10;
        while(n >= base1) {
            int temp;
            if (n / base1 >= 10) {
                base2 = base1 * 10;
                count += n / base2 * base1;
                temp = n % base2;
            }
            else {
                temp = n;
            }
            
            count += max(min(base1, temp - base1 + 1), 0);
            
            if (INT_MAX / 10 < base1) break;
            base1 *= 10;
        }
        return count;
    }
};